'use client';

import React, { useState, useEffect } from 'react';
import { collection, addDoc, updateDoc, doc, getDoc, serverTimestamp, Timestamp, FieldValue } from 'firebase/firestore';
import { firestore } from '@/lib/firebaseClient';
import { supabase } from '@/lib/supabaseClient';
import { useRouter } from 'next/navigation';
import Image from 'next/image';

// Interface for the data stored in Firestore (adjust as needed)
interface FirestoreDbProduct {
    slug: string;
    name: { sr: string; en: string };
    artist: { sr: string; en: string };
    price: number;
    isActive: boolean;
    isNew: boolean;
    isOnSale: boolean;
    saleMultiplier: number;
    imageURL: string;
    createdAt?: Timestamp | FieldValue;
    updatedAt?: Timestamp | FieldValue;
}

// Interface for the form state (flatter structure)
interface ProductFormData {
    slug: string;
    name_sr: string;
    name_en: string;
    artist_sr?: string; // Optional
    artist_en?: string; // Optional
    price: number;
    isActive: boolean;
    isNew: boolean;
    isOnSale: boolean;
    saleMultiplier: number;
    // Exclude fields generated by server (createdAt, updatedAt, imageURL for now)
}

interface ProductFormProps {
  productId?: string; // If present, we are in edit mode
}

export default function ProductForm({ productId }: ProductFormProps) {
  const router = useRouter();
  const isEditMode = Boolean(productId);

  const [formData, setFormData] = useState<ProductFormData>({
    slug: '',
    name_sr: '',
    name_en: '',
    artist_sr: '',
    artist_en: '',
    price: 0,
    isActive: true,
    isNew: false,
    isOnSale: false,
    saleMultiplier: 1, // Default to no discount
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [fetching, setFetching] = useState(isEditMode);
  const [imageFile, setImageFile] = useState<File | null>(null);
  const [imagePreviewUrl, setImagePreviewUrl] = useState<string | null>(null);
  const [isUploading, setIsUploading] = useState(false);

  // Fetch existing product data if in edit mode
  useEffect(() => {
    if (isEditMode && productId) {
      const fetchProduct = async () => {
        setFetching(true);
        setError(null);
        try {
          const productDocRef = doc(firestore, 'products', productId);
          const docSnap = await getDoc(productDocRef);

          if (docSnap.exists()) {
            const data = docSnap.data() as FirestoreDbProduct;
            // Map Firestore data to flat form state
            setFormData({
              slug: data.slug || '',
              name_sr: data.name?.sr || '',
              name_en: data.name?.en || '',
              artist_sr: data.artist?.sr || '',
              artist_en: data.artist?.en || '',
              price: data.price || 0,
              isActive: data.isActive === undefined ? true : data.isActive,
              isNew: data.isNew || false,
              isOnSale: data.isOnSale || false,
              saleMultiplier: data.saleMultiplier === undefined ? 1 : data.saleMultiplier,
            });
            if (data.imageURL) {
              setImagePreviewUrl(data.imageURL);
            }
          } else {
            setError('Product not found.');
            console.error('No such document!');
            // Optionally redirect or show a persistent error
          }
        } catch (err) {
          console.error('Error fetching product data:', err);
          setError('Failed to load product data.');
        } finally {
          setFetching(false);
        }
      };
      fetchProduct();
    }
  }, [productId, isEditMode]);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
    const { name, value, type } = e.target;

    if (type === 'checkbox') {
      const { checked } = e.target as HTMLInputElement;
      setFormData((prev) => ({ ...prev, [name]: checked }));
    } else if (type === 'number') {
      setFormData((prev) => ({ ...prev, [name]: parseFloat(value) || 0 }));
    } else {
      setFormData((prev) => ({ ...prev, [name]: value }));
    }
  };

  const handleImageChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files[0]) {
      const file = e.target.files[0];
      setImageFile(file);
      // Create a preview URL
      const reader = new FileReader();
      reader.onloadend = () => {
        setImagePreviewUrl(reader.result as string);
      };
      reader.readAsDataURL(file);
    } else {
      setImageFile(null);
      // If clearing the file input, potentially revert to original image in edit mode
      // For now, just clear preview or handle as needed
      // setImagePreviewUrl(isEditMode ? initialImageUrl : null); // Need to store initial URL separately if needed
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError(null);

    if (!formData.slug || !formData.name_sr || !formData.name_en) {
        setError('Slug and Name (both SR and EN) are required.');
        setLoading(false);
        return;
    }

    let uploadedImageUrl = imagePreviewUrl;

    // --- Image Upload Logic --- 
    if (imageFile) {
        setIsUploading(true);
        try {
            // Ensure a unique file path, e.g., using slug and timestamp
            const fileExt = imageFile.name.split('.').pop();
            const uniqueFileName = `${formData.slug.trim()}-${Date.now()}.${fileExt}`;
            const filePath = `product-images/${uniqueFileName}`; // Adjust bucket path if needed

            const { data: uploadData, error: uploadError } = await supabase.storage
                .from('product-images') // Your bucket name
                .upload(filePath, imageFile, {
                    cacheControl: '3600', // Optional: Cache control
                    upsert: false, // Set to true to overwrite if file exists, false to error
                });

            if (uploadError) {
                throw uploadError;
            }

            // Get the public URL
            const { data: urlData } = supabase.storage
                .from('product-images')
                .getPublicUrl(filePath);

             if (!urlData || !urlData.publicUrl) {
                throw new Error('Could not get public URL for uploaded image.');
             }

            uploadedImageUrl = urlData.publicUrl;
            console.log('Image uploaded successfully:', uploadedImageUrl);

        } catch (uploadError: any) {
            console.error('Supabase upload error:', uploadError);
            setError(`Image upload failed: ${uploadError.message}`);
            setIsUploading(false);
            setLoading(false);
            return; // Stop submission if upload fails
        } finally {
            setIsUploading(false);
        }
    } else if (isEditMode && !uploadedImageUrl) {
        // Handle case where image might have been removed in edit mode (set URL to '' or keep old one based on requirements)
        console.log('No new image selected, and no existing image URL found. Saving without image.');
        uploadedImageUrl = ''; // Set to empty string if image is intentionally removed
    }

    // Prepare data in Firestore format
    const productDataToSave: Partial<FirestoreDbProduct> = {
        slug: formData.slug.trim(),
        name: { sr: formData.name_sr.trim(), en: formData.name_en.trim() },
        artist: {
            sr: formData.artist_sr?.trim() || '',
            en: formData.artist_en?.trim() || '',
        },
        price: formData.price,
        isActive: formData.isActive,
        isNew: formData.isNew,
        isOnSale: formData.isOnSale,
        saleMultiplier: formData.saleMultiplier,
        imageURL: uploadedImageUrl || '',
        updatedAt: serverTimestamp(),
    };

    // Conditionally add createdAt only if NOT in edit mode
    if (!isEditMode) {
        productDataToSave.createdAt = serverTimestamp();
    }

    try {
      if (isEditMode && productId) {
        // Update existing document
        const productDocRef = doc(firestore, 'products', productId);
        await updateDoc(productDocRef, productDataToSave);
        console.log('Product updated successfully');
        alert('Product updated successfully!');
      } else {
        // Add new document
        const productsCollection = collection(firestore, 'products');
        await addDoc(productsCollection, productDataToSave);
        console.log('Product added successfully');
        alert('Product added successfully!');
      }
      router.push('/bojanicnikola'); // Redirect back to the admin dashboard
    } catch (err: any) {
      console.error(`Error ${isEditMode ? 'updating' : 'adding'} product:`, err);
      setError(`Failed to ${isEditMode ? 'update' : 'add'} product. Please check the data and try again.`);
    } finally {
      setLoading(false);
    }
  };

  if (fetching) {
      return <p>Loading product data...</p>;
  }

  // Show persistent error if fetching failed
  if (isEditMode && error && !formData.slug) {
      return <p className="text-red-500">Error: {error}</p>;
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-6 p-4 bg-white shadow rounded-lg">
        <h2 className="text-xl font-semibold">{isEditMode ? 'Edit Product' : 'Add New Product'}</h2>

        {/* Basic Info */}<div>
            <label htmlFor="slug" className="block text-sm font-medium text-gray-700">Slug (Unique ID)</label>
            <input type="text" name="slug" id="slug" value={formData.slug} onChange={handleChange} required className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" />
        </div><div>
            <label htmlFor="name_sr" className="block text-sm font-medium text-gray-700">Name (Serbian)</label>
            <input type="text" name="name_sr" id="name_sr" value={formData.name_sr} onChange={handleChange} required className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" />
        </div><div>
            <label htmlFor="name_en" className="block text-sm font-medium text-gray-700">Name (English)</label>
            <input type="text" name="name_en" id="name_en" value={formData.name_en} onChange={handleChange} required className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" />
        </div><div>
            <label htmlFor="artist_sr" className="block text-sm font-medium text-gray-700">Artist (Serbian - Optional)</label>
            <input type="text" name="artist_sr" id="artist_sr" value={formData.artist_sr} onChange={handleChange} className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" />
        </div><div>
            <label htmlFor="artist_en" className="block text-sm font-medium text-gray-700">Artist (English - Optional)</label>
            <input type="text" name="artist_en" id="artist_en" value={formData.artist_en} onChange={handleChange} className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" />
        </div><div>
            <label htmlFor="price" className="block text-sm font-medium text-gray-700">Price (RSD)</label>
            <input type="number" name="price" id="price" value={formData.price} onChange={handleChange} required min="0" step="0.01" className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" />
        </div>

        {/* Image Upload */}
        <div>
            <label htmlFor="image" className="block text-sm font-medium text-gray-700">Product Image</label>
            <input
                type="file"
                name="image"
                id="image"
                accept="image/png, image/jpeg, image/webp" // Specify acceptable file types
                onChange={handleImageChange}
                className="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100"
            />
            {isUploading && <p className="text-sm text-blue-600 mt-1">Uploading image...</p>}
            {imagePreviewUrl && (
                <div className="mt-4">
                    <p className="text-sm font-medium text-gray-700 mb-1">Image Preview:</p>
                    <Image src={imagePreviewUrl} alt="Product Preview" width={150} height={200} className="object-contain border rounded" />
                    {/* Option to remove image? */}
                </div>
            )}
        </div>

        {/* Flags / Metadata */}<div className="grid grid-cols-2 md:grid-cols-4 gap-4 items-center">
            <div className="flex items-center">
                <input type="checkbox" name="isActive" id="isActive" checked={formData.isActive} onChange={handleChange} className="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500" />
                <label htmlFor="isActive" className="ml-2 block text-sm text-gray-900">Is Active?</label>
            </div><div className="flex items-center">
                <input type="checkbox" name="isNew" id="isNew" checked={formData.isNew} onChange={handleChange} className="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500" />
                <label htmlFor="isNew" className="ml-2 block text-sm text-gray-900">Is New?</label>
            </div><div className="flex items-center">
                <input type="checkbox" name="isOnSale" id="isOnSale" checked={formData.isOnSale} onChange={handleChange} className="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500" />
                <label htmlFor="isOnSale" className="ml-2 block text-sm text-gray-900">Is On Sale?</label>
            </div>
        </div>

        {/* Sale Multiplier (only relevant if isOnSale is true) */} {formData.isOnSale && (
            <div>
                <label htmlFor="saleMultiplier" className="block text-sm font-medium text-gray-700">Sale Multiplier (e.g., 0.8 for 20% off)</label>
                <input type="number" name="saleMultiplier" id="saleMultiplier" value={formData.saleMultiplier} onChange={handleChange} required min="0" max="1" step="0.01" className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" />
            </div>
        )}

        {/* Submit Button and Error Message */} {error && <p className="text-red-500 text-sm text-center">{error}</p>}

        <div className="flex justify-end space-x-3">
             <button type="button" onClick={() => router.back()} className="px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                Cancel
            </button>
             <button type="submit" disabled={loading} className="px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50">
                {loading ? 'Saving...' : 'Save Product'}
            </button>
        </div>
    </form>
  );
} 